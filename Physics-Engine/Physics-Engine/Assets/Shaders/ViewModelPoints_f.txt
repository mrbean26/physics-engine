#version 330 core
in vec3 fragPosition;
in vec3 normalCoords;
in vec4 directionalFragPosLightSpaces[15];
out vec4 FragColor;

uniform vec3 colour;

struct PointLight {
	vec3 position;
	
	float ambient;
	float diffuse;
	float specular;

	float intensity;

	float attenuationConstant;
	float attenuationLinear;
	float attenuationQuadratic;
};
struct DirectionalLight {
	vec3 position;
	vec3 direction;
	
	float ambient;
	float diffuse;
	float specular;

	float intensity;
	float cutOff;
	float outerCutOff;

	float attenuationConstant;
	float attenuationLinear;
	float attenuationQuadratic;
};

// Number of Lights to process. Maximum number of each type of light in a scene is 30.
uniform vec3 viewPosition;

uniform int pointLightCount;
uniform float pointShadowFars[15];
uniform samplerCube pointShadowMaps[15];
uniform PointLight allPointLights[15];

uniform int directionalLightCount;
uniform sampler2D directionalShadowMaps[15];
uniform DirectionalLight allDirectionalLights[15];

float ShadowCalculationDirectional(int lightIndex) {
    // perform perspective divide
    vec3 projCoords = directionalFragPosLightSpaces[lightIndex].xyz / directionalFragPosLightSpaces[lightIndex].w;
    // transform to [0,1] range
    projCoords = projCoords * 0.5 + 0.5;
    // get closest depth value from light's perspective (using [0,1] range fragPosLight as coords)
    float closestDepth = texture(directionalShadowMaps[lightIndex], projCoords.xy).r; 
    // get depth of current fragment from light's perspective
    float currentDepth = projCoords.z;
    // check whether current frag pos is in shadow
	float bias = 0.5f;
    float shadow = currentDepth - bias > closestDepth  ? 1.0 : 0.0;
	
    return shadow;
}  
float ShadowCalculationPoint(int lightIndex) {
    // get vector between fragment position and light position
    vec3 fragToLight = fragPosition - allPointLights[lightIndex].position;
    // ise the fragment to light vector to sample from the depth map    
    float closestDepth = texture(pointShadowMaps[lightIndex], fragToLight).r;
    // it is currently in linear range between [0,1], let's re-transform it back to original depth value
    closestDepth *= pointShadowFars[lightIndex];
    // now get current linear depth as the length between the fragment and light position
    float currentDepth = length(fragToLight);
    // test for shadows
    float bias = 0.5f; // we use a much larger bias since depth is now in [near_plane, far_plane] range
    float shadow = currentDepth -  bias > closestDepth ? 1.0 : 0.0;        
    // display closestDepth as debug (to visualize depth cubemap)
    // FragColor = vec4(vec3(closestDepth / far_plane), 1.0);    
        
    return shadow;
}

// Light Calculation Functions
vec3 calculatePointLight(PointLight light, vec3 originalColour, vec3 normal, vec3 fragPosition, vec3 viewDirection, int lightIndex) {
	vec3 lightDirection = normalize(light.position - fragPosition);
	
	// diffuse
	float diffuse = max(dot(lightDirection, normal), 0.0f);

	// specular
	vec3 reflectDirection = reflect(-lightDirection, normal);
	float specular = max(dot(viewDirection, reflectDirection), 0.0f);
	
	// ambient
	float ambient = light.ambient;

	// attenuation
	float distance = length(light.position - fragPosition);
	float attenuation = light.intensity / (light.attenuationConstant + light.attenuationLinear * distance + light.attenuationQuadratic * pow(distance, 2.0f));
	
	// lighting
	ambient = ambient * attenuation;
	diffuse = diffuse * attenuation;
	specular = specular * attenuation;
	
	float shadow = ShadowCalculationPoint(lightIndex);                      
        
	return (ambient + (1.0f - shadow) * (diffuse + specular)) * originalColour;		
}
vec3 calculateDirectionalLight(DirectionalLight light, vec3 originalColour, vec3 normal, vec3 fragPosition, vec3 viewDirection, int lightIndex) {
	vec3 lightDirection = normalize(light.position - fragPosition);
	
	// diffuse 
	float diffuse = max(dot(normal, lightDirection), 0.0f);
	
	// specular 
	vec3 reflectDirection = reflect(-lightDirection, normal);
	float specular = max(dot(viewDirection, reflectDirection), 0.0f);
	 
	// ambient 
	float ambient = light.ambient;
	 
	// attenuation 
	float distance = length(light.position - fragPosition);
	float attenuation = light.intensity / (light.attenuationConstant + light.attenuationLinear * distance + light.attenuationQuadratic * pow(distance, 2.0f));
	
	// intensity due to direction 
	float theta = dot(lightDirection, normalize(-light.direction));
	float epsilon = light.cutOff - light.outerCutOff;
	float intensity = clamp((theta - light.outerCutOff) / epsilon, 0.0f, 1.0f);
	float overallIntensity = intensity * light.intensity;
	
	// lighting 
	ambient = ambient * attenuation * overallIntensity;
	diffuse = diffuse * attenuation * overallIntensity;
	specular = specular * attenuation * overallIntensity;
	
	float shadow = ShadowCalculationDirectional(lightIndex);
	
	return (ambient + (1.0 - shadow) * (diffuse + specular)) * originalColour;
}	

// Colour Generation
void main(){
	vec3 originalColour = vec3(0.0f);
	vec3 viewDirection = normalize(viewPosition - fragPosition);
	
	for(int i = 0; i < pointLightCount; i++) {
		originalColour = originalColour + calculatePointLight(allPointLights[i], colour, normalCoords, fragPosition, viewDirection, i);
	}
	for(int i = 0; i < directionalLightCount; i++) {
		originalColour = originalColour + calculateDirectionalLight(allDirectionalLights[i], colour, normalCoords, fragPosition, viewDirection, i);
	}
	
	FragColor = vec4(originalColour, 1.0f);
}